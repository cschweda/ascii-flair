// scripts/compile-fonts.js
import figlet from 'figlet'
import { writeFileSync, mkdirSync, existsSync } from 'fs'
import { resolve, dirname } from 'path'
import { fileURLToPath } from 'url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const FONTS_DIR = resolve(__dirname, '../src/fonts')

// Curated font list
const FONTS = [
  'Standard',
  'Big',
  'Small',
  'Banner',
  'Block',
  'Doom',
  'Slant',
  'Shadow',
  'Isometric1',
  'Mini',
  'Short',
  'Thin',
  'Bubble',
  'Digital',
  'Graffiti',
  'ANSI Regular',
  'Cybermedium',
  'Rectangles'
]

// Characters to include in font data
const CHARS = ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'

function extractFont(fontName) {
  return new Promise((resolve, reject) => {
    const charMap = {}
    let height = 0

    let pending = CHARS.length
    for (const char of CHARS) {
      figlet.text(char, { font: fontName }, (err, result) => {
        if (err) {
          pending--
          if (pending === 0) resolve({ charMap, height })
          return
        }
        const lines = result.split('\n')
        while (lines.length && lines[lines.length - 1].trim() === '') {
          lines.pop()
        }
        if (lines.length > height) height = lines.length
        charMap[char] = lines
        pending--
        if (pending === 0) resolve({ charMap, height })
      })
    }
  })
}

async function compileFont(fontName) {
  console.log(`Compiling: ${fontName}`)
  const { charMap, height } = await extractFont(fontName)

  for (const char of Object.keys(charMap)) {
    while (charMap[char].length < height) {
      charMap[char].push('')
    }
  }

  const safeName = fontName.toLowerCase().replace(/\s+/g, '-')
  const moduleContent = `// Pre-compiled font: ${fontName}\n// Generated by ascii-flair compile-fonts.js — do not edit\nexport default ${JSON.stringify({ name: fontName, height, chars: charMap })}\n`

  const outPath = resolve(FONTS_DIR, `${safeName}.js`)
  writeFileSync(outPath, moduleContent, 'utf8')
  console.log(`  → src/fonts/${safeName}.js`)
}

async function main() {
  if (!existsSync(FONTS_DIR)) {
    mkdirSync(FONTS_DIR, { recursive: true })
  }

  const fontEntries = []

  for (const font of FONTS) {
    try {
      await compileFont(font)
      const safeName = font.toLowerCase().replace(/\s+/g, '-')
      fontEntries.push({ name: font, file: safeName })
    } catch (err) {
      console.warn(`  ⚠ Skipping ${font}: ${err.message}`)
    }
  }

  const registryContent = `// Auto-generated font registry — do not edit\nexport const FONT_REGISTRY = ${JSON.stringify(
    Object.fromEntries(fontEntries.map(f => [f.file, f.name]))
  , null, 2)}\n\nexport const FONT_NAMES = ${JSON.stringify(fontEntries.map(f => f.file))}\n`

  writeFileSync(resolve(FONTS_DIR, '_registry.js'), registryContent, 'utf8')
  console.log(`\nCompiled ${fontEntries.length} fonts.`)
}

main().catch(err => {
  console.error(err)
  process.exit(1)
})
